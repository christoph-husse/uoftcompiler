CSC488/2107 Assignment 5
Term: Winter 2013
Group: c488h08


Who Did What
===========================================================================

c0sunkue: Test Cases
c9bukals: Statements
c2weizhe: Function/Procedure Invocation
c2shaoyu: Expressions, Variables, PDF Generator
c3hussec: C++ validation & Test-suite updates


Documentation
===========================================================================

Storage

Storage is implemented as described in templates/expressions.txt.
Scalar variables have a fixed offset from the start of the scope, and
their offset is recorded in the AST at their declaration node. Arrays
begin at a fixed offset from the start of the scope, and have a fixed
length. Accesses are implemented by looking up the start of the scope
from the display, then adding the fixed offset to get the address of
the variable. Arrays are subscripted by adding the subscript in
addition to the offset. Non-1 lower bounds for arrays are implemented
by inlining the lower bound (negated) into the order number (ON) for
the address load instruction (ADDR).


Expressions

Expressions are implemented as described in templates/expressions.txt.
Expressions that are leaves in the AST (eg. constants, variable
access) generate code that pushes those values onto the top of the
stack. Expressions that are made up of subexpressions (eg. operators)
recursively evaluate the subexpressions first, then generate code that
performs the operation and pushes the result onto the top of the
stack.


Statements

Statements are implemented as described in templates/statements.txt.
If statements resolve branch addresses internally by recording the PC
address of the branch target address, storing a dummy address, and
then replacing with the correct address once it is available at the
end of code generation. Loop statements resolve the branch address by
saving the PC at the start of code generation. When loops are visited,
the exit address of the loop is saved for use by exit statements. Exit
statements resolve branch addresses internally by recording the PC
address of the branch target and replacing. In the case of exits with
level, the PC and target loop is recorded into a hashmap which is used
to resolve these branches at the end of all program code generation. 


Function/Procedure Invocation

Functions and Procedures have a large amount of common implementation.
We use `Routine` to refer to both.

The calling convention is as follows:

-   Caller will push arguments, save current display entry at callee's
	level, push return address, and finally jump to callee.

-   Callee will will reserver space for local variables, set offsets
	for parameters and local variables, and finally run the code.

-   After callee finishes running the code, it will clean up local
	variables and return to caller.

-   After callee returns, caller will restore display entry, clean up
	arguments, and put the return value (if any) on top of stack.

Return value is passes through a special register `REG_RV` which is
allocated at address 0x4 on the stack. There is code around the
beginning to jump over this address so that normal execution is not
affected.

During code generation, some target addresses for instruction BR may
not be available. We mark all these addresses as holes and fill them
up at the end of code generation.


Extra Features

AST Visual Printouts

Visual PDF printouts can be generated automatically for any valid 488
source code file. Using "make graphs" in the root directory will
generate printouts of every test case in testing/pass/, and place the
results in the 'graphs' directory. Graph generation is done similarly
to code generation. A visitor (ast/ASTGraphPrinter.java) walks the AST
depth first, and generates code in the DOT graph description language.
The DOT code contains a visual node for each significant AST node, and
draws edges connecting each node with its children. Some nodes are
printed with a special label for conciseness (eg. Identifier nodes are
labeled with the name of the identifier), while the remaining nodes
are labelled with their java class name (eg. RoutineDeclaration) for
easy searching in the PDF viewer. See the graphs/ directory for
example PDFs of our test cases.


Test Cases

Test cases were designed to print out as much information as possible
and be compared with output generated by our validator. For more
information on how the validator works, please refer to
testing/README.tests and "Using the compiler.pdf".


Java Classes

The vast majority of the code is unchanged from assignment 3. We added
codegen.CodeGenASTVisitor, which traverses the AST using the visitor
pattern and generates code for the pseudomachine. We also added
ast.ASTGraphPrinter, which works the same way but instead generates
code in DOT language for the creation of PDF graphs. Small changes
were made to symbol.SymbolTable to keep track of stack offsets for
variables, testing.TestSuite to support automated testing and
validation against equivalent C++ code, and various AST node classes
for convenience functions used during code generation.

compiler488/
├── ast
│   ├── ASTGraphPrinter.java
│   ├── ASTLexicalOrderVisitor.java
│   ├── ASTList.java
│   ├── ASTNode.java
│   ├── ASTPrettyPrinter.java
│   ├── ASTPrinter488.java
│   ├── ASTPrinter488CPPShared.java
│   ├── ASTPrinterCPP.java
│   ├── ASTVisitor.java
│   ├── ASTVisitorAdapter.java
│   ├── Cached.java
│   ├── FixedIterable.java
│   ├── IASTNodeCallback.java
│   ├── SemanticException.java
│   ├── decl
│   │   ├── ArrayDeclaration.java
│   │   ├── Declaration.java
│   │   ├── ForwardDeclaration.java
│   │   ├── ParameterDeclaration.java
│   │   ├── RoutineDeclaration.java
│   │   └── VariableDeclaration.java
│   ├── expn
│   │   ├── Access.java
│   │   ├── AndOperator.java
│   │   ├── ArrayAccess.java
│   │   ├── BinaryArithmeticOperator.java
│   │   ├── BinaryBooleanOperator.java
│   │   ├── BinaryOperator.java
│   │   ├── BinaryOperators.java
│   │   ├── BoolConst.java
│   │   ├── ComparisonOperator.java
│   │   ├── Const.java
│   │   ├── DivisionOperator.java
│   │   ├── EqualOperator.java
│   │   ├── Expression.java
│   │   ├── FunctionInvocation.java
│   │   ├── GreaterEqualOperator.java
│   │   ├── GreaterOperator.java
│   │   ├── Identifier.java
│   │   ├── IntConst.java
│   │   ├── LessEqualOperator.java
│   │   ├── LessOperator.java
│   │   ├── MinusOperator.java
│   │   ├── MultiplicationOperator.java
│   │   ├── NotEqualOperator.java
│   │   ├── OrOperator.java
│   │   ├── PlusOperator.java
│   │   ├── StringConst.java
│   │   ├── UnaryMinus.java
│   │   ├── UnaryNot.java
│   │   ├── UnaryOperator.java
│   │   └── VariableAccess.java
│   ├── stmt
│   │   ├── Assignment.java
│   │   ├── ExitStatement.java
│   │   ├── GetInvocation.java
│   │   ├── IfStatement.java
│   │   ├── LoopStatement.java
│   │   ├── ProcedureInvocation.java
│   │   ├── PutInvocation.java
│   │   ├── ResultStatement.java
│   │   ├── ReturnStatement.java
│   │   ├── Scope.java
│   │   └── Statement.java
│   └── type
│       ├── BooleanType.java
│       ├── IntegerType.java
│       ├── StringType.java
│       └── Type.java
├── codegen
│   └── CodeGenASTVisitor.java
├── compiler
│   ├── CompilerMain.java
│   ├── Console.java
│   ├── CppCompiler.java
│   ├── FileContainer.java
│   ├── OutputFileFormat.java
│   ├── ReportVerbosity.java
│   └── TraceModule.java
├── parser
│   ├── Location.java
│   ├── Report.java
│   ├── SyntaxErrorException.java
│   ├── csc488.cup
│   └── csc488.flex
├── runtime
│   ├── ExecutionException.java
│   ├── Machine.java
│   ├── MemoryAddressException.java
│   └── TextReader.java
├── semantics
│   ├── SemanticASTVisitor.java
│   ├── SemanticError.java
│   ├── Semantics.java
│   ├── Semantics_Chris.java
│   ├── Semantics_Cloud.java
│   ├── Semantics_Jack.java
│   ├── Semantics_Steven.java
│   └── Semantics_Zheng.java
├── symbol
│   ├── SymbolEntry.java
│   └── SymbolTable.java
└── testing
    └── TestSuite.java

